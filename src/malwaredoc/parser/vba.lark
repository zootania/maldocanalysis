%import common.ESCAPED_STRING
%import common.WS
%import common.DIGIT
%import common.HEXDIGIT
%import common.LETTERORDIGIT
%import common.LETTER
%import common.IDENTIFIER

// Start and module structure
?start: module

module: (module_header end_of_line*)? module_config? end_of_line* module_attributes? end_of_line* module_declarations? end_of_line* module_body? end_of_line*

module_header: VERSION WS DOUBLELITERAL (WS CLASS)?

module_config: BEGIN (WS GUID WS ambiguous_identifier)? end_of_line* module_config_element+ END

module_config_element: ambiguous_identifier WS? EQ WS? literal (COLON literal)? end_of_line*

// Adjusted so we can have just attributes
module_attributes: (attribute_stmt end_of_line*)+

module_declarations: module_declarations_element (end_of_line+ module_declarations_element)* end_of_line*

module_declarations_element: comment | declare_stmt | enumeration_stmt | event_stmt | const_stmt | implements_stmt | variable_stmt | module_option | type_stmt | deftype_stmt | macro_stmt

macro_stmt: macro_const_stmt | macro_if_then_else_stmt

module_option: OPTION_BASE WS SHORTLITERAL | OPTION_COMPARE WS (BINARY | TEXT | DATABASE) | OPTION_EXPLICIT | OPTION_PRIVATE_MODULE

// module_body: module_body_element (end_of_line+ module_body_element)* end_of_line*

// module_body_element: function_stmt | property_get_stmt | property_set_stmt | property_let_stmt | sub_stmt | macro_stmt

module_body: module_body_element+

module_body_element: function_stmt 
                    | property_get_stmt 
                    | property_set_stmt 
                    | property_let_stmt 
                    | sub_stmt 
                    | macro_stmt

attribute_stmt: ATTRIBUTE WS implicit_call_stmt_in_stmt WS? EQ WS? literal (WS? "," WS? literal)*

block: block_stmt (end_of_statement block_stmt)* end_of_statement

block_stmt: line_label | appactivate_stmt | attribute_stmt | beep_stmt | chdir_stmt | chdrive_stmt | close_stmt | const_stmt | date_stmt | delete_setting_stmt | do_loop_stmt | end_stmt | erase_stmt | error_stmt | exit_stmt | explicit_call_stmt | filecopy_stmt | for_each_stmt | for_next_stmt | get_stmt | go_sub_stmt | go_to_stmt | if_then_else_stmt | implements_stmt | input_stmt | kill_stmt | let_stmt | line_input_stmt | line_number | load_stmt | lock_stmt | lset_stmt | macro_stmt | mid_stmt | mkdir_stmt | name_stmt | on_error_stmt | on_go_to_stmt | on_go_sub_stmt | open_stmt | print_stmt | put_stmt | raise_event_stmt | randomize_stmt | redim_stmt | reset_stmt | resume_stmt | return_stmt | rmdir_stmt | rset_stmt | save_picture_stmt | save_setting_stmt | seek_stmt | select_case_stmt | sendkeys_stmt | setattr_stmt | set_stmt | stop_stmt | time_stmt | unload_stmt | unlock_stmt | variable_stmt | while_wend_stmt | width_stmt | with_stmt | write_stmt | implicit_call_stmt_in_block | implicit_call_stmt_in_stmt

appactivate_stmt: APPACTIVATE WS value_stmt (WS? "," WS? value_stmt)?

beep_stmt: BEEP

chdir_stmt: CHDIR WS value_stmt

chdrive_stmt: CHDRIVE WS value_stmt

close_stmt: CLOSE (WS file_number (WS? "," WS? file_number)*)?

const_stmt: (visibility WS)? CONST WS const_sub_stmt (WS? "," WS? const_sub_stmt)*

const_sub_stmt: ambiguous_identifier type_hint? (WS as_type_clause)? WS? EQ WS? value_stmt

date_stmt: DATE WS? EQ WS? value_stmt

declare_stmt: (visibility WS)? DECLARE WS (PTRSAFE WS)? ((FUNCTION type_hint?) | SUB) WS ambiguous_identifier type_hint? WS LIB WS STRINGLITERAL (WS ALIAS WS STRINGLITERAL)? (WS? arg_list)? (WS as_type_clause)?

deftype_stmt: (DEFBOOL | DEFBYTE | DEFINT | DEFLNG | DEFCUR | DEFSNG | DEFDBL | DEFDEC | DEFDATE | DEFSTR | DEFOBJ | DEFVAR) WS letter_range (WS? "," WS? letter_range)*

delete_setting_stmt: DELETESETTING WS value_stmt WS? "," WS? value_stmt (WS? "," WS? value_stmt)?

do_loop_stmt: DO end_of_statement block? LOOP | DO WS (WHILE | UNTIL) WS value_stmt end_of_statement block? LOOP | DO end_of_statement block LOOP WS (WHILE | UNTIL) WS value_stmt

end_stmt: END

enumeration_stmt: (visibility WS)? ENUM WS ambiguous_identifier end_of_statement enumeration_stmt_constant* END_ENUM

enumeration_stmt_constant: ambiguous_identifier (WS? EQ WS? value_stmt)? end_of_statement

// erase_stmt: "ERASE" WS value_stmt ("," WS? value_stmt)*?
erase_stmt: ERASE WS value_stmt ("," WS? value_stmt)*

error_stmt: ERROR WS value_stmt

event_stmt: (visibility WS)? EVENT WS ambiguous_identifier WS? arg_list

exit_stmt: EXIT_DO | EXIT_FOR | EXIT_FUNCTION | EXIT_PROPERTY | EXIT_SUB

filecopy_stmt: FILECOPY WS value_stmt WS? "," WS? value_stmt

for_each_stmt: FOR WS EACH WS ambiguous_identifier type_hint? WS IN WS value_stmt end_of_statement block? NEXT (WS ambiguous_identifier)?

for_next_stmt: FOR WS ambiguous_identifier type_hint? (WS as_type_clause)? WS? EQ WS? value_stmt WS TO WS value_stmt (WS STEP WS value_stmt)? end_of_statement block? NEXT (WS ambiguous_identifier)?

function_stmt: (visibility WS)? (STATIC WS)? FUNCTION WS? ambiguous_identifier type_hint? (WS? arg_list)? (WS? as_type_clause)? end_of_statement block? END_FUNCTION

get_stmt: GET WS file_number WS? "," WS? value_stmt? WS? "," WS? value_stmt

go_sub_stmt: GOSUB WS value_stmt

go_to_stmt: GOTO WS value_stmt

if_then_else_stmt: IF WS if_condition_stmt WS THEN WS block_stmt (WS ELSE WS block_stmt)? | if_block_stmt if_else_if_block_stmt* if_else_block_stmt? END_IF

if_block_stmt: IF WS if_condition_stmt WS THEN end_of_statement block?

if_condition_stmt: value_stmt

if_else_if_block_stmt: ELSEIF WS if_condition_stmt WS THEN end_of_statement block?

if_else_block_stmt: ELSE end_of_statement block?

implements_stmt: IMPLEMENTS WS ambiguous_identifier

input_stmt: INPUT WS file_number (WS? "," WS? value_stmt)+

kill_stmt: KILL WS value_stmt

let_stmt: (LET WS)? implicit_call_stmt_in_stmt WS? (EQ | PLUS_EQ | MINUS_EQ) WS? type_hint? value_stmt type_hint?

line_input_stmt: LINE_INPUT WS file_number WS? "," WS? value_stmt

line_number: (INTEGERLITERAL | SHORTLITERAL) NEWLINE? COLON? NEWLINE? WS?

load_stmt: LOAD WS value_stmt

lock_stmt: LOCK WS value_stmt (WS? "," WS? value_stmt (WS TO WS value_stmt)?)?

lset_stmt: LSET WS implicit_call_stmt_in_stmt WS? EQ WS? value_stmt

macro_const_stmt: MACRO_CONST WS? ambiguous_identifier WS? EQ WS? value_stmt

macro_if_then_else_stmt: macro_if_block_stmt macro_else_if_block_stmt* macro_else_block_stmt? MACRO_END_IF

macro_if_block_stmt: MACRO_IF WS? if_condition_stmt WS THEN end_of_statement (module_declarations | module_body | block)*

macro_else_if_block_stmt: MACRO_ELSEIF WS? if_condition_stmt WS THEN end_of_statement (module_declarations | module_body | block)*

macro_else_block_stmt: MACRO_ELSE end_of_statement (module_declarations | module_body | block)*

mid_stmt: MID WS? LPAREN WS? args_call WS? RPAREN

mkdir_stmt: MKDIR WS value_stmt

name_stmt: NAME WS value_stmt WS AS WS value_stmt

on_error_stmt: (ON_ERROR | ON_LOCAL_ERROR) WS (GOTO WS value_stmt | RESUME WS NEXT)

on_go_to_stmt: ON WS value_stmt WS GOTO WS value_stmt (WS? "," WS? value_stmt)*

on_go_sub_stmt: ON WS value_stmt WS GOSUB WS value_stmt (WS? "," WS? value_stmt)*

open_stmt: OPEN WS value_stmt WS FOR WS (APPEND | BINARY | INPUT | OUTPUT | RANDOM) (WS ACCESS WS (READ | WRITE | READ_WRITE))? (WS (SHARED | LOCK_READ | LOCK_WRITE | LOCK_READ_WRITE))? WS AS WS file_number (WS LEN WS? EQ WS? value_stmt)?

output_list: output_list_expression (WS? (";" | ",") WS? output_list_expression?)* | output_list_expression? (WS? (";" | ",") WS? output_list_expression?)+

output_list_expression: value_stmt | (SPC | TAB) (WS? LPAREN WS? args_call WS? RPAREN)?

print_stmt: PRINT WS file_number WS? "," (WS? output_list)?

property_get_stmt: (visibility WS)? (STATIC WS)? PROPERTY_GET WS ambiguous_identifier type_hint? (WS? arg_list)? (WS as_type_clause)? end_of_statement block? END_PROPERTY

property_set_stmt: (visibility WS)? (STATIC WS)? PROPERTY_SET WS ambiguous_identifier (WS? arg_list)? end_of_statement block? END_PROPERTY

property_let_stmt: (visibility WS)? (STATIC WS)? PROPERTY_LET WS ambiguous_identifier (WS? arg_list)? end_of_statement block? END_PROPERTY

put_stmt: PUT WS file_number WS? "," WS? value_stmt? WS? "," WS? value_stmt

raise_event_stmt: RAISEEVENT WS ambiguous_identifier (WS? LPAREN WS? (args_call WS?)? RPAREN)?

randomize_stmt: RANDOMIZE (WS value_stmt)?

redim_stmt: REDIM WS (PRESERVE WS)? redim_sub_stmt (WS? "," WS? redim_sub_stmt)*

redim_sub_stmt: implicit_call_stmt_in_stmt WS? LPAREN WS? subscripts WS? RPAREN (WS as_type_clause)?

reset_stmt: RESET

resume_stmt: RESUME (WS (NEXT | ambiguous_identifier))?

return_stmt: RETURN

rmdir_stmt: RMDIR WS value_stmt

rset_stmt: RSET WS implicit_call_stmt_in_stmt WS? EQ WS? value_stmt

save_picture_stmt: SAVEPICTURE WS value_stmt WS? "," WS? value_stmt

save_setting_stmt: SAVESETTING WS value_stmt WS? "," WS? value_stmt WS? "," WS? value_stmt WS? "," WS? value_stmt

seek_stmt: SEEK WS file_number WS? "," WS? value_stmt

select_case_stmt: SELECT WS CASE WS value_stmt end_of_statement s_c_case* END_SELECT

s_c_selection: IS WS? comparison_operator WS? value_stmt | value_stmt WS TO WS value_stmt | value_stmt

s_c_case: CASE WS s_c_cond end_of_statement block?

s_c_cond: ELSE | s_c_selection (WS? "," WS? s_c_selection)*

sendkeys_stmt: SENDKEYS WS value_stmt (WS? "," WS? value_stmt)?

setattr_stmt: SETATTR WS value_stmt WS? "," WS? value_stmt

set_stmt: SET WS implicit_call_stmt_in_stmt WS? EQ WS? value_stmt

stop_stmt: STOP

sub_stmt: (visibility WS)? (STATIC WS)? SUB WS? ambiguous_identifier (WS? arg_list)? end_of_statement block? END_SUB

time_stmt: TIME WS? EQ WS? value_stmt

type_stmt: (visibility WS)? TYPE WS ambiguous_identifier end_of_statement type_stmt_element* END_TYPE

type_stmt_element: ambiguous_identifier (WS? LPAREN (WS? subscripts)? WS? RPAREN)? (WS as_type_clause)? end_of_statement

type_of_stmt: TYPEOF WS value_stmt (WS IS WS type_)?

unload_stmt: UNLOAD WS value_stmt

unlock_stmt: UNLOCK WS file_number (WS? "," WS? value_stmt (WS TO WS value_stmt)?)?

value_stmt: literal | implicit_call_stmt_in_stmt | LPAREN WS? value_stmt (WS? "," WS? value_stmt)* RPAREN | NEW WS? value_stmt | type_of_stmt | mid_stmt | ADDRESSOF WS? value_stmt | implicit_call_stmt_in_stmt WS? ASSIGN WS? value_stmt | value_stmt WS? POW WS? value_stmt | MINUS WS? value_stmt | PLUS WS? value_stmt | value_stmt WS? (DIV | MULT) WS? value_stmt | value_stmt WS? MOD WS? value_stmt | value_stmt WS? (PLUS | MINUS) WS? value_stmt | value_stmt WS? AMPERSAND WS? value_stmt | value_stmt WS? (IS | LIKE | GEQ | LEQ | GT | LT | NEQ | EQ) WS? value_stmt | NOT WS? value_stmt | value_stmt WS? AND WS? value_stmt | value_stmt WS? OR WS? value_stmt | value_stmt WS? XOR WS? value_stmt | value_stmt WS? EQV WS? value_stmt | value_stmt WS? IMP WS? value_stmt

variable_stmt: (DIM | STATIC | visibility) WS (WITHEVENTS WS)? variable_list_stmt

variable_list_stmt: variable_sub_stmt (WS? "," WS? variable_sub_stmt)*

variable_sub_stmt: ambiguous_identifier (WS? LPAREN WS? (subscripts WS?)? RPAREN WS?)? type_hint? (WS as_type_clause)?

while_wend_stmt: WHILE WS value_stmt end_of_statement block? WEND

width_stmt: WIDTH WS file_number WS? "," WS? value_stmt

with_stmt: WITH WS (implicit_call_stmt_in_stmt | (NEW WS type_)) end_of_statement block? END_WITH

write_stmt: WRITE WS file_number WS? "," (WS? output_list)?

file_number: "#"? value_stmt

explicit_call_stmt: e_c_s_procedure_call | e_c_s_member_procedure_call

e_c_s_procedure_call: CALL WS ambiguous_identifier type_hint? (WS? LPAREN WS? args_call WS? RPAREN)? (WS? LPAREN subscripts RPAREN)*

e_c_s_member_procedure_call: CALL WS implicit_call_stmt_in_stmt? "." ambiguous_identifier type_hint? (WS? LPAREN WS? args_call WS? RPAREN)? (WS? LPAREN subscripts RPAREN)*

implicit_call_stmt_in_block: i_c_s_b_member_procedure_call | i_c_s_b_procedure_call

i_c_s_b_member_procedure_call: implicit_call_stmt_in_stmt? "." ambiguous_identifier type_hint? (WS args_call)? dictionary_call_stmt? (WS? LPAREN subscripts RPAREN)*

i_c_s_b_procedure_call: certain_identifier (WS args_call)? (WS? LPAREN subscripts RPAREN)*

implicit_call_stmt_in_stmt: i_c_s_s_members_call | i_c_s_s_variable_or_procedure_call | i_c_s_s_procedure_or_array_call | i_c_s_s_dictionary_call

i_c_s_s_variable_or_procedure_call: ambiguous_identifier type_hint? dictionary_call_stmt? (WS? LPAREN subscripts RPAREN)*

i_c_s_s_procedure_or_array_call: (ambiguous_identifier | base_type) type_hint? WS? LPAREN WS? (args_call WS?)? RPAREN dictionary_call_stmt? (WS? LPAREN subscripts RPAREN)*

i_c_s_s_members_call: (i_c_s_s_variable_or_procedure_call | i_c_s_s_procedure_or_array_call)? i_c_s_s_member_call+ dictionary_call_stmt? (WS? LPAREN subscripts RPAREN)*

i_c_s_s_member_call: LINE_CONTINUATION? ("." | "!") LINE_CONTINUATION? (i_c_s_s_variable_or_procedure_call | i_c_s_s_procedure_or_array_call)

i_c_s_s_dictionary_call: dictionary_call_stmt

args_call: (arg_call? WS? ("," | ";") WS?)* arg_call (WS? ("," | ";") WS? arg_call?)*

arg_call: LPAREN? ((BYVAL | BYREF | PARAMARRAY) WS)? RPAREN? value_stmt

dictionary_call_stmt: "!" ambiguous_identifier type_hint?

arg_list: LPAREN (WS? arg (WS? "," WS? arg)*)? WS? RPAREN

arg: (OPTIONAL WS)? ((BYVAL | BYREF) WS)? (PARAMARRAY WS)? ambiguous_identifier type_hint? (WS? LPAREN WS? RPAREN)? (WS? as_type_clause)? (WS? arg_default_value)?

arg_default_value: EQ WS? value_stmt

subscripts: subscript_ (WS? "," WS? subscript_)*

subscript_: (value_stmt WS TO WS)? type_hint? value_stmt type_hint?

ambiguous_identifier: (IDENTIFIER | ambiguous_keyword)+

as_type_clause: AS WS? (NEW WS)? type_ (WS? field_length)?

base_type: BOOLEAN | BYTE | COLLECTION | DATE | DOUBLE | INTEGER | LONG | SINGLE | STRING (WS? MULT WS? value_stmt)? | VARIANT

certain_identifier: IDENTIFIER (ambiguous_keyword | IDENTIFIER)* | ambiguous_keyword (ambiguous_keyword | IDENTIFIER)+

comparison_operator: LT | LEQ | GT | GEQ | EQ | NEQ | IS | LIKE

complex_type: ambiguous_identifier (("." | "!") ambiguous_identifier)*

field_length: MULT WS? (INTEGERLITERAL | ambiguous_identifier)

letter_range: certain_identifier (WS? MINUS WS? certain_identifier)?

line_label: ambiguous_identifier ":"

literal: HEXLITERAL | OCTLITERAL | DATELITERAL | DOUBLELITERAL | INTEGERLITERAL | SHORTLITERAL | ALLSTRINGLITERALS | custom_string  | STRINGLITERAL | TRUE | FALSE | NOTHING | NULL_ 

// We add this to handle literals such as C:/Users/ and "C:\Users\" & Environ("USERNAME")
ALLSTRINGLITERALS: ESCAPED_STRING | /[^ \t\r\n\f(){};]+/
STRINGLITERAL: "\"" ( | DOUBLE_QUOTE_ESCAPE | /[^"]/)* "\""
DOUBLE_QUOTE_ESCAPE: "\"\""


// Define a custom string literal to handle backslashes and concatenation within strings
custom_string: ESCAPED_STRING | /"((?:[^"\\]|\\.)*)"/
concatenation: expression "WS? & WS?" expression
expression: literal | concatenation | function_stmt

type_: (base_type | complex_type) (WS? LPAREN WS? RPAREN)?

type_hint: "&" | "%" | "#" | "!" | "@" | "$"

visibility: PRIVATE | PUBLIC | FRIEND | GLOBAL

ambiguous_keyword: ACCESS | ADDRESSOF | ALIAS | AND | ATTRIBUTE | APPACTIVATE | APPEND | AS | BEEP | BEGIN | BINARY | BOOLEAN | BYVAL | BYREF | BYTE | CALL | CASE | CLASS | CLOSE | CHDIR | CHDRIVE | COLLECTION | CONST | DATABASE | DATE | DECLARE | DEFBOOL | DEFBYTE | DEFCUR | DEFDBL | DEFDEC | DEFDATE | DEFINT | DEFLNG | DEFOBJ | DEFSNG | DEFSTR | DEFVAR | DELETESETTING | DIM | DO | DOUBLE | EACH | ELSE | ELSEIF | END | ENUM | EQV | ERASE | ERROR | EVENT | FALSE | FILECOPY | FRIEND | FOR | FUNCTION | GET | GLOBAL | GOSUB | GOTO | IF | IMP | IMPLEMENTS | IN | INPUT | IS | INTEGER | KILL | LOAD | LOCK | LONG | LOOP | LEN | LET | LIB | LIKE | LSET | ME | MID | MKDIR | MOD | NAME | NEXT | NEW | NOT | NOTHING | NULL_ | ON | OPEN | OPTIONAL | OR | OUTPUT | PARAMARRAY | PRESERVE | PRINT | PRIVATE | PUBLIC | PUT | RANDOM | RANDOMIZE | RAISEEVENT | READ | REDIM | REM | RESET | RESUME | RETURN | RMDIR | RSET | SAVEPICTURE | SAVESETTING | SEEK | SELECT | SENDKEYS | SET | SETATTR | SHARED | SINGLE | SPC | STATIC | STEP | STOP | STRING | SUB | TAB | TEXT | THEN | TIME | TO | TRUE | TYPE | TYPEOF | UNLOAD | UNLOCK | UNTIL | VARIANT | VERSION | WEND | WHILE | WIDTH | WITH | WITHEVENTS | WRITE | XOR

rem_comment: REMCOMMENT

comment: COMMENT

end_of_line: WS? (NEWLINE | comment | rem_comment) WS?

end_of_statement: (end_of_line | WS? COLON WS?)*

ACCESS: "ACCESS"
ADDRESSOF: "ADDRESSOF"
ALIAS: "ALIAS"
AND: "AND"
ATTRIBUTE: "ATTRIBUTE"
APPACTIVATE: "APPACTIVATE"
APPEND: "APPEND"
AS: "AS"
BEGIN: "BEGIN"
BEEP: "BEEP"
BINARY: "BINARY"
BOOLEAN: "BOOLEAN"
BYVAL: "BYVAL"
BYREF: "BYREF"
BYTE: "BYTE"
CALL: "CALL"
CASE: "CASE"
CHDIR: "CHDIR"
CHDRIVE: "CHDRIVE"
CLASS: "CLASS"
CLOSE: "CLOSE"
COLLECTION: "COLLECTION"
CONST: "CONST"
DATABASE: "DATABASE"
DATE: "DATE"
DECLARE: "DECLARE"
DEFBOOL: "DEFBOOL"
DEFBYTE: "DEFBYTE"
DEFDATE: "DEFDATE"
DEFDBL: "DEFDBL"
DEFDEC: "DEFDEC"
DEFCUR: "DEFCUR"
DEFINT: "DEFINT"
DEFLNG: "DEFLNG"
DEFOBJ: "DEFOBJ"
DEFSNG: "DEFSNG"
DEFSTR: "DEFSTR"
DEFVAR: "DEFVAR"
DELETESETTING: "DELETESETTING"
DIM: "DIM"
DO: "DO"
DOUBLE: "DOUBLE"
EACH: "EACH"
ELSE: "ELSE"
ELSEIF: "ELSEIF"
END_ENUM: END WS ENUM
END_FUNCTION: END WS FUNCTION
END_IF: END WS "IF"
END_PROPERTY: END WS "PROPERTY"
END_SELECT: END WS "SELECT"
END_SUB: END WS SUB
END_TYPE: END WS TYPE
END_WITH: END WS WITH
END: "END"
ENUM: "ENUM"
EQV: "EQV"
ERASE: "ERASE"
ERROR: "ERROR"
EVENT: "EVENT"
EXIT: "EXIT"
EXIT_DO: EXIT WS DO
EXIT_FOR: EXIT WS FOR
EXIT_FUNCTION: EXIT WS FUNCTION
EXIT_PROPERTY: EXIT WS PROPERTY
EXIT_SUB: EXIT WS SUB
FALSE: "FALSE"
FILECOPY: "FILECOPY"
FRIEND: "FRIEND"
FOR: "FOR"
FUNCTION: "FUNCTION"
GET: "GET"
GLOBAL: "GLOBAL"
GOSUB: "GOSUB"
GOTO: "GOTO"
IF: "IF"
IMP: "IMP"
IMPLEMENTS: "IMPLEMENTS"
IN: "IN"
INPUT: "INPUT"
IS: "IS"
INTEGER: "INTEGER"
KILL: "KILL"
LOAD: "LOAD"
LOCK: "LOCK"
LONG: "LONG"
LOOP: "LOOP"
LEN: "LEN"
LET: "LET"
LIB: "LIB"
LIKE: "LIKE"
LINE: "LINE"
LINE_INPUT: LINE WS INPUT
LOCK_READ: LOCK WS READ
LOCK_WRITE: LOCK WS WRITE
LOCK_READ_WRITE: LOCK WS READ WS WRITE
LSET: "LSET"
MACRO_CONST: "#CONST"
MACRO_IF: "#" IF
MACRO_ELSEIF: "#" ELSEIF
MACRO_ELSE: "#" ELSE
MACRO_END_IF: "#" END WS? IF
ME: "ME"
MID: "MID"
MKDIR: "MKDIR"
MOD: "MOD"
NAME: "NAME"
NEXT: "NEXT"
NEW: "NEW"
NOT: "NOT"
NOTHING: "NOTHING"
NULL_: "NULL"
ON: "ON"
ON_ERROR: "ON" WS "ERROR"
ON_LOCAL_ERROR: "ON" WS "LOCAL" WS "ERROR"
OPEN: "OPEN"
OPTIONAL: "OPTIONAL"
OPTION_BASE: "OPTION" WS "BASE"
OPTION_EXPLICIT: "OPTION" WS "EXPLICIT"
OPTION_COMPARE: "OPTION" WS "COMPARE"
OPTION_PRIVATE_MODULE: "OPTION" WS "PRIVATE" WS "MODULE"
OR: "OR"
OUTPUT: "OUTPUT"
PARAMARRAY: "PARAMARRAY"
PRESERVE: "PRESERVE"
PRINT: "PRINT"
PRIVATE: "PRIVATE"
PROPERTY: "PROPERTY"
PROPERTY_GET: PROPERTY WS "GET"
PROPERTY_LET: PROPERTY WS "LET"
PROPERTY_SET: PROPERTY WS "SET"
PTRSAFE: "PTRSAFE"
PUBLIC: "PUBLIC"
PUT: "PUT"
RANDOM: "RANDOM"
RANDOMIZE: "RANDOMIZE"
RAISEEVENT: "RAISEEVENT"
READ: "READ"
READ_WRITE: "READ" WS "WRITE"
REDIM: "REDIM"
REM: "REM"
RESET: "RESET"
RESUME: "RESUME"
RETURN: "RETURN"
RMDIR: "RMDIR"
RSET: "RSET"
SAVEPICTURE: "SAVEPICTURE"
SAVESETTING: "SAVESETTING"
SEEK: "SEEK"
SELECT: "SELECT"
SENDKEYS: "SENDKEYS"
SET: "SET"
SETATTR: "SETATTR"
SHARED: "SHARED"
SINGLE: "SINGLE"
SPC: "SPC"
STATIC: "STATIC"
STEP: "STEP"
STOP: "STOP"
STRING: "STRING"
SUB: "SUB"
TAB: "TAB"
TEXT: "TEXT"
THEN: "THEN"
TIME: "TIME"
TO: "TO"
TRUE: "TRUE"
TYPE: "TYPE"
TYPEOF: "TYPEOF"
UNLOAD: "UNLOAD"
UNLOCK: "UNLOCK"
UNTIL: "UNTIL"
VARIANT: "VARIANT"
VERSION: "VERSION"
WEND: "WEND"
WHILE: "WHILE"
WIDTH: "WIDTH"
WITH: "WITH"
WITHEVENTS: "WITHEVENTS"
WRITE: "WRITE"
XOR: "XOR"
AMPERSAND: "&"
ASSIGN: ":="
DIV: "\\" | "/"
EQ: "="
GEQ: ">="
GT: ">"
LEQ: "<="
LPAREN: "("
LT: "<"
MINUS: "-"
MINUS_EQ: "-="
MULT: "*"
NEQ: "<>"
PLUS: "+"
PLUS_EQ: "+="
POW: "^"
RPAREN: ")"

OCTLITERAL: "&O" /[0-7]+/ "&"?
HEXLITERAL: "&H" /[0-9A-F]+/ "&"?
SHORTLITERAL: (PLUS | MINUS)? DIGIT+
INTEGERLITERAL: SHORTLITERAL ("E" SHORTLITERAL)?
DOUBLELITERAL: (PLUS | MINUS)? DIGIT* "." DIGIT+ ("E" SHORTLITERAL)?
DATELITERAL: "#" DATEORTIME "#"
DATEORTIME: DATEVALUE WS? TIMEVALUE | DATEVALUE | TIMEVALUE
DATEVALUE: DATEVALUEPART DATESEPARATOR DATEVALUEPART (DATESEPARATOR DATEVALUEPART)?
DATEVALUEPART: DIGIT+ | MONTHNAME
DATESEPARATOR: WS? ("-"|"/"|",")? WS?
MONTHNAME: ENGLISHMONTHNAME | ENGLISHMONTHABBREVIATION
ENGLISHMONTHNAME: "JANUARY" | "FEBRUARY" | "MARCH" | "APRIL" | "MAY" | "JUNE | AUGUST" | "SEPTEMBER" | "OCTOBER" | "NOVEMBER" | "DECEMBER"
ENGLISHMONTHABBREVIATION: "JAN" | "FEB" | "MAR" | "APR" | "JUN" | "JUL" | "AUG" | "SEP" | "OCT" | "NOV" | "DEC"
TIMEVALUE: DIGIT+ AMPM | DIGIT+ TIMESEPARATOR DIGIT+ (TIMESEPARATOR DIGIT+)? AMPM?
TIMESEPARATOR: WS? (":" | ".") WS?
AMPM: WS? ("AM"i | "PM"i | "A"i | "P"i)
NEWLINE: /\\r?\\n|\\u2028|\\u2029/+
REMCOMMENT: COLON? "REM" WS (LINE_CONTINUATION | /.+/s)*
COMMENT: SINGLEQUOTE (LINE_CONTINUATION | /[^\r\n\u2028\u2029]+/)*
COLON: ":"
UNDERSCORE: "_"

// Define BLOCK as a sequence of four HEXDIGIT
BLOCK: HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT

// Define GUID with the specific format, using BLOCKs and MINUS as separators
GUID: "{" BLOCK BLOCK "-" BLOCK "-" BLOCK "-" BLOCK "-" BLOCK BLOCK BLOCK "}"


// Define the IDENTIFIER rule in Lark
IDENTIFIER: /[^\[\]()\r\n\t.,'"|!@#$%^&*\-+:=; ]+/ 
          | "[" /[^\]!\r\n]+/ "]"

// Define L_SQUARE_BRACKET and R_SQUARE_BRACKET if they are used elsewhere in your grammar
L_SQUARE_BRACKET: "["
R_SQUARE_BRACKET: "]"

SINGLEQUOTE: "'"
LINE_CONTINUATION: /(\t| )+_\r?\n[\t ]*/  // Adjust to match your needs

// Use %ignore to skip over the line continuation sequences during parsing
%ignore LINE_CONTINUATION
%ignore WS