"""Extract special features from data."""
import base64
import re
from enum import Enum
from typing import List, Optional

import langdetect
from langdetect import LangDetectException

from malwaredoc.data.base import Base


class IPType(Enum):
    IPV4 = 4
    IPV6 = 6


class IPData(Base):
    ip: str
    type: IPType


class Base64Data(Base):
    """Stores base64 data."""

    raw: str
    decoded: str


class Base32Data(Base):
    raw: str
    decoded: str


class StringAnalysisResult(Base):
    raw: Optional[str]
    language: Optional[str]
    has_ip: bool
    has_ip_v4: bool
    has_ip_v6: bool
    has_base64: bool
    has_base32: bool
    ips: List[IPData]
    base64: Optional[List[Base64Data]]
    base32: Optional[List[Base32Data]]


def _extract_ips(string: str) -> List[IPData]:
    """
    Extracts all IP addresses (both IPv4 and IPv6) from the input string.
    Args:
        string: string to extract ips from.

    Returns:
        list: A list of tuples. Each tuple contains an IP address and its type (IPv4 or IPv6).

    """
    if string is None:
        return []
    ipv4_pattern = r"\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b"
    ipv6_pattern = r"\b(?:[A-Fa-f0-9]{1,4}:){7}[A-Fa-f0-9]{1,4}\b"

    ipv4_matches = re.findall(ipv4_pattern, string)
    ipv6_matches = re.findall(ipv6_pattern, string)

    results = [IPData(ip=match, type=IPType.IPV4) for match in ipv4_matches]
    results.extend(IPData(ip=match, type=IPType.IPV6) for match in ipv6_matches)
    return results


def _extract_base64(string: str) -> List[Base64Data]:
    """
    Extract base64 encoded data from string.
    Args:
        string: string with base64 data.

    Returns: list of :class:`Base64Data`

    """
    if string is None:
        return []
    pattern = r"(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})"
    matches = re.findall(pattern, string)
    results = []
    for match in matches:
        try:
            decoded_string = base64.b64decode(match).decode("utf-8")
            results.append(Base64Data(raw=match, decoded=decoded_string))  # maybe match[0] instead?
        except Exception:
            continue
    return results


def _extract_base32(string: str) -> List[Base32Data]:
    """
    Extract base32 encoded data from string.
    Args:
        string: string with base32 data.

    Returns: list of :class:`Base32Data`

    """
    if string is None:
        return []
    pattern = r"(?:[A-Z2-7]{8})*(?:[A-Z2-7]{2}={6}|[A-Z2-7]{4}={4}|[A-Z2-7]{5}={3}|[A-Z2-7]{7}=)?"
    matches = re.findall(pattern, string)
    results = []
    for match in matches:
        try:
            if len(match) <= 0:
                continue
            decoded_string = base64.b32decode(match).decode("utf-8")
            results.append(Base32Data(raw=match, decoded=decoded_string))
        except Exception:
            continue
    return results


def _detect_language(string: str) -> str:
    """Determing language of a string.

    Args:
        string (str): string.

    Returns:
        str: language identifier (eg. 'ko' for Korean).
    """
    if string and string != "":
        try:
            return langdetect.detect(string)
        except LangDetectException:
            return ""
    return ""


class StringAnalyzer:
    """Analyze strings for malicious contents"""

    def __init__(self) -> None:
        pass

    def analyze(self, string: str, extract_base64: bool = False, extract_base32: bool = False) -> StringAnalysisResult:
        """
        Analyze string content.
        Args:
            string: string to analyze.

        Returns: :class:`AnalysisResult`

        """
        language = _detect_language(string)
        ips = _extract_ips(string)
        base64_content = None
        base32_content = None
        has_base32 = False
        has_base64 = False
        if extract_base64:
            base64_content = _extract_base64(string)
            has_base64 = len(base64_content) > 0
        if extract_base32:
            base32_content = _extract_base32(string)
            has_base32 = len(base32_content) > 0
        has_ip = len(ips) > 0
        has_ip_v4 = False
        has_ip_v6 = False
        if has_ip:
            for ip_data in ips:
                if ip_data.type == IPType.IPV4:
                    has_ip_v4 = True
                elif ip_data.type == IPType.IPV6:
                    has_ip_v6 = True

        return StringAnalysisResult(
            raw=string,
            language=language,
            has_ip=has_ip,
            has_base32=has_base32,
            has_base64=has_base64,
            ips=ips,
            base32=base32_content,
            base64=base64_content,
            has_ip_v6=has_ip_v6,
            has_ip_v4=has_ip_v4,
        )
