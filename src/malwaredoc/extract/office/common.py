"""Data extraction tools for Microsoft Office files (ole)"""
from __future__ import annotations
import logging

from pathlib import Path
from typing import Any, Dict, List, Optional

import oletools.mraptor
import oletools.msodde
import oletools.oleid
import oletools.oleobj
import textract
from oletools.olevba import VBA_Parser
from oletools import ftguess, oleobj, ooxml

from malwaredoc.data.base import Base, Dictable, ValidatorModel


class VBAMacro(Base):
    filename: str  # ignored in analysis
    stream_path: str  # ignored in analysis
    vba_code: str


class VBAData(Base, Dictable):
    has_macro: bool
    macros: List[VBAMacro]

    def get_vba_macros(self) -> str:
        """
        Get all vba macros in one string.
        Returns:
            str with VBA macros.
        """
        return "".join(macro.vba_code + "\r\n" for macro in self.macros)

    def to_dict(self) -> Dict[str, Any]:
        return {"has_macro": self.has_macro, "macros": self.get_vba_macros()}


def has_vba_code(path: Path) -> bool:
    """
    Check if file has vba macros.
    Args:
        path: path to file.

    Returns: True if ole file and contains macros.
    """
    result = False
    try:
        parser = VBA_Parser(filename=str(path.resolve()))
        result = parser.detect_macros()
        parser.close()
    except Exception as vba_error:
        logging.error(f"Failed to determine if file has VBA for file path {path}: {vba_error}")
    if result == None:
        result = False
    return result


def get_vba_code(path: Path) -> VBAData:
    """
    Extract vba code from file if possible.
    Args:
        path: path to file.

    Returns: 'VBAData' object.

    """
    result = VBAData(has_macro=False, macros=[])
    try:
        vba_parser = VBA_Parser(filename=str(path.resolve()))
        vba_files = [
            VBAMacro(
                filename=vba_filename,
                stream_path=stream_path,
                vba_code=vba_code,
            )
            for filename, stream_path, vba_filename, vba_code in vba_parser.extract_all_macros()
        ]
        vba_parser.close()
        result = VBAData(has_macro=True, macros=vba_files)
    except Exception as vba_error:
        logging.error(f"VBA extraction failed on the path {path}: because {vba_error}")
    return result


def get_vba_code_all_modules(path: Path) -> str:
    """Get vba code for all modules.

    Args:
        path (Path): path to file.

    Returns:
        str: vba code.
    """
    if has_vba_code(path):
        vba_parser = VBA_Parser(filename=str(path.resolve()))
        result = vba_parser.get_vba_code_all_modules()
        vba_parser.close()
        return result
    return ""


class MraptorResult(Base, Dictable):
    suspicious: bool
    flags: List[str] | str
    matches: List[str]
    autoexec: bool
    exec: bool
    write: bool

    def to_dict(self) -> Dict[str, Any]:
        return {"suspicious": self.suspicious, "autoexec": self.autoexec, "exec": self.exec, "write": self.write}


def get_mraptor_analysis(path: Path) -> MraptorResult:
    """Analyze file with mraptor.

    Args:
        path (Path): path to file.

    Returns:
        MraptorResult: summary of vba code analysis with mraptor
    """
    code = get_vba_code_all_modules(path)
    mraptor = oletools.mraptor.MacroRaptor(vba_code=code)
    mraptor.scan()
    return MraptorResult(
        suspicious=mraptor.suspicious,
        flags=mraptor.get_flags(),
        matches=mraptor.matches,
        autoexec=mraptor.autoexec,
        exec=mraptor.execute,
        write=mraptor.write,
    )


def get_text_content(path: Path, extension: str) -> Optional[str]:
    """
    Extract all text content from an office file.
    Args:
        path: path to file.

    Returns: all text content as a string.

    """
    try:
        return textract.process(path, extension=extension).decode("utf-8")
    except Exception:
        return None


class Indicator(Base):
    id: Optional[str]
    name: Optional[str]
    type: Optional[str]
    value: Optional[str]
    description: Optional[str]


def get_indicators(path: Path) -> List[Indicator]:
    """Get indicators for a file.

    Args:
        path (Path): file path.

    Returns:
        List[Indicator]: file indicators.
    """
    try:
        oid = oletools.oleid.OleID(path)
        indicators = oid.check()
        return [
            Indicator(
                id=i.id,
                name=i.name,
                type=i.type.__name__,
                value=repr(i.value),
                description=i.description,
            )
            for i in indicators
        ]
    except Exception:
        print(f"Checking file indicators failed for: {path}")
        return []


def parse_ole_embedded_obj(path: Path) -> None:
    """Parse ole object and look for embedded objects and relationships.

    The output will be printed.
    This also works on zip files.

    Args:
        path (Path): path to file.
    """
    oletools.oleobj.process_file(filename=path.resolve(), data=None, output_dir="/temp")


class VBAAnalysis(Base):
    keyword_type: str
    keyword: str
    description: str

    def summarize_analysis(self) -> str:
        return f"{self.keyword_type}: {self.keyword}\n{self.description}"

class ExternalRelationships(ValidatorModel, Base, Dictable):
    relationship_type: str
    relationship_value: str

    def to_dict(self) -> dict[str, str]:
        return {"relationship_type": self.relationship_type, "relationship_value": self.relationship_value}

class DDEStream(ValidatorModel, Base, Dictable):
    dde_stream: Optional[str]

    def to_dict(self) -> dict[str, str]:
        if not self:
            return {"dde_stream": ""}
        return {"dde_stream": self.dde_stream}

def get_dde_streams(path: Path) -> Optional[DDEStream]:
    result: DDEStream = DDEStream(dde_stream="")
    try:
        result = DDEStream(dde_stream=oletools.msodde.process_file(path))
    except Exception as dde_exception:
        logging.warning(f"DDE Parsing Exception: {dde_exception}")
    return result


def get_external_relationship(path: Path) -> List[ExternalRelationships]:
    found_relationships: list[ExternalRelationships] = []
    try:
        xmlparser = ooxml.XmlParser(path)
    except Exception as xml_parsing_error:
        logging.error(f"File not parsed as XML because: {xml_parsing_error}")
    if not xmlparser:
        return found_relationships
    
    try:
        for rel_type, target in oleobj.find_external_relationships(xmlparser):
            found_relationships.append(
                ExternalRelationships(relationship_type=rel_type, relationship_value=target)
            )
    except Exception:
        logging.info("File {path}: has no relationships and could not be parsed")
    return found_relationships


def get_vba_code_analysis(path: Path) -> List[VBAAnalysis]:
    """Analyze files vba code.

    Args:
        path (Path): path to file.

    Returns:
        List[VBAAnalysis]: analysis of vba macros.
    """
    if has_vba_code(path):
        vbaparser = VBA_Parser(filename=str(path.resolve()))
        results = vbaparser.analyze_macros()
        analysis = [VBAAnalysis(keyword_type=kw_t, keyword=kw, description=desc) for kw_t, kw, desc in results]
        vbaparser.close()
        return analysis
    return []


def get_dde_analysis(path: Path) -> Any:
    """_summary_

    Args:
        path (Path): _description_

    Returns:
        Any: _description_
    """
    # Todo: This needs to be tested!
    return oletools.msodde.process_file(path.resolve())
