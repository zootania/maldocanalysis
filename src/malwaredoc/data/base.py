from abc import ABC, abstractmethod
import logging
from typing import Any, Dict, Optional

from pydantic import BaseModel, Field, validator
from pydantic import BaseModel, ValidationInfo, field_validator
from typing import get_origin, get_args, Union, List, Optional

class Base(BaseModel):
    model_config = {"arbitrary_types_allowed": True}

    def __hash__(self):
        return hash((type(self),) + tuple(self.__dict__.values()))

def is_optional_list_of_str(type_hint) -> bool:
    """Determines if a type hint is an Optional list with elements that are str.

    Args:
        type_hint: The type hint to inspect.

    Returns:
        bool: True if the type hint represents an Optional list of str elements, False otherwise.
    """
    # Handle Optional by extracting the non-None type if present
    if get_origin(type_hint) == Union:
        type_hint = next((arg for arg in get_args(type_hint) if arg is not type(None)), None)
        if type_hint is None:
            return False

    # Return False early if the type is not a list
    if get_origin(type_hint) != list:
        return False

    # Check list element types
    list_args = get_args(type_hint)
    # Return False early if list_args is empty or does not specify element types
    if not list_args:
        return False

    element_type = list_args[0]
    # Handle Union element types
    if get_origin(element_type) == Union:
        return all(subtype in [str] for subtype in get_args(element_type))
    else:
        # Directly check if element type is str or int
        return element_type in [str]
    
class ValidatorModel(BaseModel):
    """
        We use before in the mode for all the validators because we are using these functions to coerce types. 
        https://docs.pydantic.dev/2.2/usage/validators/#before-after-wrap-and-plain-validators
    """
    @field_validator('*', mode="before")
    @classmethod
    def ensure_only_str(cls, v: Any, info: ValidationInfo) -> Any:
        """
        Ensures that fields annotated as str or Optional[str] are strings.

        Args:
            v (Any): The value to validate.
            info (ValidationInfo): Information about the field being validated.

        Returns:
            Any: The original string value, a converted string value, or an empty string if `v` is None.
        """

        if cls.model_fields[info.field_name].annotation in [str, Optional[str]]:
            if v is None:
                return ""
            return str(v)
        return v
        
    @field_validator('*', mode="before")
    @classmethod
    def ensure_integers(cls, v: Any, info: ValidationInfo) -> Any:
        """
        Ensures that fields annotated as int or Optional[int] are integers.

        Args:
            v (Any): The value to validate.
            info (ValidationInfo): Information about the field being validated.

        Returns:
            Any: The original integer value, a converted integer value, or 0 if `v` is None.
        """
        if cls.model_fields[info.field_name].annotation in [int, Optional[int]]:
            return int(v) if v is not None else 0
        return v

    @field_validator('*', mode="before")
    @classmethod
    def ensure_floats(cls, v: Any, info: ValidationInfo) -> Any:
        """
        Ensures that fields annotated as float or Optional[float] are floats.

        Args:
            v (Any): The value to validate.
            info (ValidationInfo): Information about the field being validated.

        Returns:
            Any: The original float value, a converted float value, or 0.0 if `v` is None.
        """
        if cls.model_fields[info.field_name].annotation in [float, Optional[float]]:
            return float(v) if v is not None else 0.0
        return v

    @field_validator('*', mode="before")
    @classmethod
    def ensure_list_items_are_str(cls, v: Any, info: ValidationInfo) -> Any:
        """
        Ensures that fields annotated as list[str].

        Args:
            v (Any): The value to validate.
            info (ValidationInfo): Information about the field being validated.

        Returns:
            Any: The original kust value, a converted list value, or [] if `v` is None.
        """
        if is_optional_list_of_str(cls.model_fields[info.field_name].annotation):
            if not isinstance(v, list):
                return [str(v)]
            if v is None:
                []
            return [str(item) for item in v]

        return v


class Dictable(ABC):
    @abstractmethod
    def to_dict(self) -> Dict[str, Any]:
        """
        Converts class to a dict containing all relevant attributes.
        Returns:
            dict with no lists as values.

        """
