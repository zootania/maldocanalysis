from typing import Any, Dict, List, Optional, Type, Union

import filetype

from malwaredoc.data.base import Base, Dictable
from malwaredoc.extract.metadata import (
    ExifMeta,
    FileTypeData,
    MagikaMeta,
    PDFMetadata,
    RARMetadata,
    ZIPMetadata,
)
from malwaredoc.extract.office.common import (
    DDEStream,
    ExternalRelationships,
    Indicator,
    MraptorResult,
    VBAAnalysis,
    VBAData,
)
from malwaredoc.extract.pdf import AttachmentData, ImageData
from malwaredoc.extract.rtf import RtfAnalysisResult


class FileAnalysis(Base, Dictable):
    name: str
    absolute_path: str
    type_data: Optional[FileTypeData]  # get_file_type
    text_extract: Optional[str]  # get_text_content
    magika_meta: Optional[MagikaMeta]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "absolute_path": self.absolute_path,
            "type_data": self.type_data.to_dict(),
            "text_extract": self.text_extract,
            "magika_meta": self.magika_meta.to_dict()
        }


class PdfFileAnalysis(FileAnalysis, Dictable):
    pdf_metadata: Optional[PDFMetadata]  # get_pdf_metadata
    attachments: Optional[List[AttachmentData]]  # extract_attachments_from_pdf
    image_data: Optional[List[ImageData]]  # extract_images_from _pdf
    text: Optional[str]  # extact_text_from_pdf

    def is_encrypted(self) -> bool:
        """
        Check if pdf is encrypted.
        Returns:
            True if encrypted.
        """
        return self.pdf_metadata.is_encrypted if self.pdf_metadata else False

    def has_image_data(self) -> bool:
        """
        Check if pdf contains images.
        Returns:
            True if pdf has at least 1 image.
        """
        return len(self.image_data) > 0 if self.image_data else False

    def has_attachments(self) -> bool:
        return len(self.attachments) > 0 if self.attachments else False

    def to_dict(self) -> Dict[str, Any]:
        super_dict = super().to_dict()
        d = {
            "pdf_metadata": self.pdf_metadata.to_dict() if self.pdf_metadata else None,
            "has_attachments": self.has_attachments(),
            "has_image_data": self.has_image_data(),
            "is_encrypted": self.is_encrypted(),
            "pdf_text": self.text,  # Todo: fix this
        }
        return {**super_dict, **d}


class EditableFileAnalysis(FileAnalysis, Dictable):
    indicators: List[Indicator]  # get_indicators

    def has_indicators(self):
        return len(self.indicators) > 0

    def to_dict(self) -> Dict[str, Any]:
        super_dict = super().to_dict()
        d = {}
        for indicator in self.indicators:
            i = indicator.id
            d[f"{i}.name"] = indicator.name
            d[f"{i}.description"] = indicator.description
            d[f"{i}.value"] = indicator.value
            d[f"{i}.type"] = indicator.type
        return {**super_dict, **d}


class OfficeFileAnalysis(EditableFileAnalysis, Dictable):
    has_vba_code: bool  # has_vba_code
    vba_code: Optional[VBAData]  # get_vba_code
    vba_analysis: List[VBAAnalysis]  # get_vba_code_analysis
    mraptor_analysis: Optional[MraptorResult]  # get_mraptor_analysis
    zip_metadata: Optional[List[ZIPMetadata]]  # get_zip_metadata
    exif_metadata: Optional[ExifMeta]
    external_relationships: Optional[list[ExternalRelationships]]
    dde_stream: Optional[DDEStream]

    def has_vba_analysis(self) -> bool:
        return len(self.vba_analysis) > 0

    def has_zip_metadata(self) -> bool:
        return len(self.zip_metadata) > 0 if self.zip_metadata else False

    def _get_analysis(self) -> str:
        return "".join(analysis.summarize_analysis() + "\n" for analysis in self.vba_analysis)

    def to_dict(self) -> Dict[str, Any]:
        super_dict = super().to_dict()
        d = {
            "has_vba_code": self.has_vba_code,
            "vba_code": self.vba_code.to_dict() if self.vba_code else None,
            "vba_analysis": self._get_analysis(),
            "mraptor_analysis": self.mraptor_analysis.to_dict() if self.mraptor_analysis else None,
            "exif_metadata": self.exif_metadata,
            "external_relationships": self.external_relationships,
            "dde_stream": self.dde_stream.to_dict()
            # we do not store the zip metadata
        }
        return {**super_dict, **d}


class WordFileAnalysis(OfficeFileAnalysis, Dictable):
    paragraphs: List[str]  # get_paragraphs

    def get_text(self) -> str:
        """Get paragraphs transformed to one continuous text."""
        return "".join(paragraph + "\n" for paragraph in self.paragraphs)

    def to_dict(self) -> Dict[str, Any]:
        super_dict = super().to_dict()
        d = {"paragraphs": self.get_text()}
        return {**super_dict, **d}

class XlsxFileAnalysis(OfficeFileAnalysis, Dictable):
    xlsx_text: str

    def to_dict(self) -> Dict[str, Any]:
        super_dict = super().to_dict()
        d = {"xlsx_text": self.xlsx_text}
        return {**super_dict, **d}


class RtfFileAnalysis(FileAnalysis, Dictable):
    rtf_obj_analysis: List[RtfAnalysisResult]  # analyze_rtf
    rtf_raw: str
    rtf_text: str

    def has_rtf_obj_analysis(self) -> bool:
        return len(self.rtf_obj_analysis) > 0

    def get_number_of_ole_embedded_object(self) -> int:
        return sum(bool(obj.is_ole) for obj in self.rtf_obj_analysis)

    def get_total_embedded_size(self):
        return sum(int(obj.oledata_size) for obj in self.rtf_obj_analysis if obj.oledata_size)

    def to_dict(self) -> Dict[str, Any]:
        super_dict = super().to_dict()
        d = {
            "number_ole": self.get_number_of_ole_embedded_object(),
            "embedded_size": self.get_total_embedded_size(),
            "rtf_raw": self.rtf_raw,
            "rtf_text": self.rtf_text,
        }
        return {**super_dict, **d}


class ArchiveFileAnalysis(FileAnalysis):
    # the type hint order matters for loading the file,
    # so should be keep in the order of file hierarchy
    files: List[
        Union[
            "ZipFileAnalysis",
            "RarFileAnalysis",
            WordFileAnalysis,
            OfficeFileAnalysis,
            PdfFileAnalysis,
            RtfFileAnalysis,
            FileAnalysis,
            XlsxFileAnalysis,
        ]
    ]  # unzip_file

    def is_apk_archive(self) -> bool:
        """
        Check if file is an apk archive.
        Returns:
            True if apk archive.
        """
        return any(file.name == "AndroidManifest.xml" for file in self.files)

    def contains_file_type(self, t: Type[filetype.Type]) -> bool:
        """
        Check if file has a file of type.
        Args:
            t: type of file to look for.

        Returns:
            True if file type exists.
        """

        return any(file.type_data and isinstance(file.type_data.type_filetype, t) for file in self.files)

    def get_files_of_type(
        self, t: Type[filetype.Type]
    ) -> List[
        Union[
            FileAnalysis,
            PdfFileAnalysis,
            OfficeFileAnalysis,
            RtfFileAnalysis,
            "ZipFileAnalysis",
            "RarFileAnalysis",
            WordFileAnalysis,
            XlsxFileAnalysis,
        ]
    ]:
        """
        Get file analysis for all files of type within archive.
        Args:
            t: type of file to look for.

        Returns:
            list of files that match type.
        """
        files = [file for file in self.files if file.type_data and isinstance(file.type_data.type_filetype, t)]
        for file in files:
            file.name = f"{self.name}.{file.absolute_path}"
        return files


class ZipFileAnalysis(ArchiveFileAnalysis):
    zip_metadata: List[ZIPMetadata]  # get_zip_metadata


class RarFileAnalysis(ArchiveFileAnalysis):
    rar_metadata: List[RARMetadata]  # get_rar_metadata


class RelevantFiles(Base):
    """Storing files that are required for further analysis"""

    word_files: List[WordFileAnalysis]
    xlsx_files: List[XlsxFileAnalysis]
    rtf_files: List[RtfFileAnalysis]
    pdf_files: List[PdfFileAnalysis]
    office_files: List[OfficeFileAnalysis]
    zip_word_files: List[WordFileAnalysis]
    zip_office_files: List[OfficeFileAnalysis]
    zip_pdf_files: List[PdfFileAnalysis]
    zip_rtf_files: List[RtfFileAnalysis]
    rar_word_files: List[WordFileAnalysis]
    rar_pdf_files: List[PdfFileAnalysis]
    rar_rtf_files: List[RtfFileAnalysis]

    def get_all_word_files(self) -> List[WordFileAnalysis]:
        return self.word_files + self.zip_word_files + self.rar_pdf_files

    def get_all_xlsx_files(self) -> List[XlsxFileAnalysis]:
        return self.xlsx_files

    def get_all_pdf_files(self) -> List[PdfFileAnalysis]:
        return self.pdf_files + self.zip_pdf_files + self.rar_pdf_files

    def get_all_rtf_files(self) -> List[RtfFileAnalysis]:
        return self.rtf_files + self.zip_rtf_files + self.rar_rtf_files

    def get_all_office_files(self) -> List[OfficeFileAnalysis]:
        """
        Get all office files that are not word files.
        Returns:
            List of office file analysis results.
        """
        return self.office_files + self.zip_office_files

    def get_all_files(self) -> List[FileAnalysis]:
        return (
            self.get_all_word_files()
            + self.get_all_xlsx_files()
            + self.get_all_pdf_files()
            + self.get_all_office_files()
            + self.get_all_rtf_files()
        )
